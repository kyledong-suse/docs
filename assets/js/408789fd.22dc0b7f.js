"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6247],{43997:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>r,contentTitle:()=>t,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=a(74848),c=a(28453);const s={title:"Namespace Boundary Enforcement",taxonomy:{category:"docs"},slug:"/policy/namespaceboundary"},t=void 0,i={id:"policy/namespaceboundary/namespaceboundary",title:"Namespace Boundary Enforcement",description:"Policy: Namespace Boundary Enforcement",source:"@site/docs/05.policy/14.namespaceboundary/14.namespaceboundary.md",sourceDirName:"05.policy/14.namespaceboundary",slug:"/policy/namespaceboundary",permalink:"/next/policy/namespaceboundary",draft:!1,unlisted:!1,editUrl:"https://github.com/neuvector/docs/edit/main/docs/05.policy/14.namespaceboundary/14.namespaceboundary.md",tags:[],version:"current",sidebarPosition:14,frontMatter:{title:"Namespace Boundary Enforcement",taxonomy:{category:"docs"},slug:"/policy/namespaceboundary"},sidebar:"tutorialSidebar",previous:{title:"Importing CRD from Console",permalink:"/next/policy/usingcrd/import"},next:{title:"6. Security Risks, Scanning & Compliance",permalink:"/next/scanning"}},r={},l=[{value:"Policy: Namespace Boundary Enforcement",id:"policy-namespace-boundary-enforcement",level:3},{value:"Enable/disable namespace boundary enforcement",id:"enabledisable-namespace-boundary-enforcement",level:3},{value:"Example",id:"example",level:4}];function d(e){const n={code:"code",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h3,{id:"policy-namespace-boundary-enforcement",children:"Policy: Namespace Boundary Enforcement"}),"\n",(0,o.jsxs)(n.p,{children:["By default, pods in different namespaces, and with different labels, can communicate.\nTo avoid this behavior, it's usually needed to create additional rules to restrict it.\nThis new label, ",(0,o.jsx)(n.code,{children:"NeuvectorNamespaceBoundary"}),", allows you to implement a restriction to the communication between pods ",(0,o.jsx)(n.strong,{children:"belonging to the same namespace"})," or ",(0,o.jsx)(n.strong,{children:"sharing natural boundaries"})," (i.e. part of the same application)."]}),"\n",(0,o.jsx)(n.h3,{id:"enabledisable-namespace-boundary-enforcement",children:"Enable/disable namespace boundary enforcement"}),"\n",(0,o.jsx)(n.p,{children:"To enable or disable this policy against a namespace, you need to set the following label:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Enable ",(0,o.jsx)(n.code,{children:"Namespace Boundary Enforcement"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"kubectl label namespace <namespace> NeuvectorNamespaceBoundary=enabled"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Disable ",(0,o.jsx)(n.code,{children:"Namespace Boundary Enforcement"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"kubectl label namespace <namespace> NeuvectorNamespaceBoundary=disabled"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["[Optional] Remove the label > This will disable ",(0,o.jsx)(n.code,{children:"Namespace Boundary Enforcement"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"kubectl label namespace <namespace> NeuvectorNamespaceBoundary-"})}),"\n",(0,o.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,o.jsx)(n.p,{children:"Customer made request to policy ingress/egress traffic on namespace\u2019s natural boundary."}),"\n",(0,o.jsx)(n.p,{children:"eg.)"}),"\n",(0,o.jsx)(n.p,{children:"There are 2 namespaces ns1, ns2,"}),"\n",(0,o.jsx)(n.p,{children:"in ns1 there are pod1(with label=app1,label=one) and pod2(with label=app2, label=two),"}),"\n",(0,o.jsx)(n.p,{children:"in ns2 there are pod3(with label=app1,label=three) and pod4(with label=app2, label=four),"}),"\n",(0,o.jsx)(n.p,{children:"There are 2 groups g1, g2,"}),"\n",(0,o.jsx)(n.p,{children:'g1 is created using "label=app1" which includes pod1 and pod3'}),"\n",(0,o.jsx)(n.p,{children:'g2 is created using "label=app2" which includes pod2 and pod4'}),"\n",(0,o.jsx)(n.p,{children:"network policy: from g1 to g2 app any port any action allow"}),"\n",(0,o.jsx)(n.p,{children:"with this policy pod1 can talk to both pod2 and pod4, pod3 can talk to pod2 and pod4.\nwithout namespace boundary enforcement if user wants to only allow pod1 communicates to pod2 within same namespace ns1,\npod3 to pod4 within same namespace ns2, additional custom groups and network policies need to be created,"}),"\n",(0,o.jsx)(n.p,{children:'group g-1 is created using "label=one" which includes pod1'}),"\n",(0,o.jsx)(n.p,{children:'group g-4 is created using "label=four" which includes pod4'}),"\n",(0,o.jsx)(n.p,{children:"network policy: from g-1 to g-4 app any port any action deny"}),"\n",(0,o.jsx)(n.p,{children:'group g-3 is created using "label=three" which includes pod3'}),"\n",(0,o.jsx)(n.p,{children:'group g-2 is created using "label=two" which includes pod2'}),"\n",(0,o.jsx)(n.p,{children:"network policy: from g-3 to g-2 app any port any action deny"}),"\n",(0,o.jsx)(n.p,{children:"with namespace boundary enforcement we can realize same function, without creating additional groups and policies, to allow only pod1 talk to pod2 but not pod1 to pod4, pod3 to pod4 but not pod3 to pod2."})]})}function p(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>t,x:()=>i});var o=a(96540);const c={},s=o.createContext(c);function t(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:t(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);